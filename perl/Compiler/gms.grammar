start: (process_definition | tool_definition) eof
        { $return = $item[1]; }
    | <error>

process_definition: "process" node(s)
        { $return = Compiler::AST::Definition::Process->create(
                nodes => $item[2]);
        }

node: alias(?) type parallel_statement(?) with_statements(?)
        { $return = Compiler::AST::Node->create(
                type => $item[2],
                alias => $item[1][0] || $item[2],
                parallel => $item[3][0] || [],
                explicit_links => $item[4][0] || [],
            );
        }

alias: name "is"
        { $return = $item[1]; }
    | <error>

parallel_statement: "parallel" name(s /\*/)
        { $return = $item[2]; }

with_statements: "with" with_statement(s /,/)
        { $return = $item[2]; }

with_statement: name "from" identifier
        { $return = Compiler::AST::Link::Internal->create(
                property_name => $item[1], source => $item[3]); }
    | name "=" constant
        { $return = Compiler::AST::Link::Constant->create(
                property_name => $item[1], value => $item[3]); }
    | <error>


tool_definition: "tool" tool_command tool_inputs(?) tool_outputs(?)
        { $return = Compiler::AST::Definition::Tool->create(
                command => $item[2],
                inputs => $item[3][0] || [],
                outputs => $item[4][0] || []);
        }

tool_command: type
        { $return = $item[1]; }

tool_inputs: "inputs" tool_input(s)
        { $return = $item[2]; }

tool_input: tool_io_entry
        { $return = Compiler::AST::IO::Input->create(%{$item[1]}); }

tool_outputs: "outputs" tool_output(s)
        { $return = $item[2]; }

tool_output: tool_io_entry
        { $return = Compiler::AST::IO::Output->create(%{$item[1]}); }

tool_io_entry: type name
        { $return = { type => $item[1], name => $item[2] }; }


constant: /'(\\'|.)*'/
        { $return = substr $item[1], 1, -1; }
    | /-?[0-9][0-9_]*(.[0-9_]+)?/
        { $return = $item[1]; }
    | <error>

identifier: name
        { $return = $item[1]; }
    | type
        { $return = $item[1]; }
    | <error>

name: /[a-z][A-Za-z0-9_]*/
        { $return = $item[1]; }
type: /[A-Z][A-Za-z0-9_]*(::[A-Z][A-Za-z0-9_]*)*/
        { $return = $item[1]; }

eof: /^\Z/
